"""Matchzoo pair generator."""

from matchzoo import engine
from matchzoo import tasks
from matchzoo import datapack
from matchzoo import utils

import numpy as np
import typing


class PairGenerator(engine.BaseGenerator):
    """PairGenerator for Matchzoo.

    Pair generator can be used only for ranking.

    Examples:
        >>> data = [{
        ...     'text_left':[1], 'text_right': [2], 'id_left': 'id0',
        ...     'id_right': 'id1', 'label': 0},{
        ...     'text_left':[1], 'text_right': [3], 'id_left': 'id0',
        ...     'id_right': 'id2', 'label': 1}]
        >>> columns = ['text_left', 'text_right', 'id_left', 'id_right',
        ...     'label']
        >>> input = datapack.DataPack(data, columns=columns)
        >>> task = tasks.Ranking()
        >>> from matchzoo.generators import PairGenerator
        >>> generator = PairGenerator(input, 1, task, 1, True)
        >>> assert generator
        >>> x, y = generator[0]

    """

    def __init__(
        self,
        inputs: datapack.DataPack,
        num_neg: int=1,
        task: engine.BaseTask=tasks.Ranking(),
        batch_size: int=32,
        shuffle: bool=True
    ):
        """Construct the pair generator.

        :param inputs: the output generated by :class:`DataPack`.
        :param num_neg: the number of negative samples associated with each
            positive sample.
        :param task: the task is a instance of :class:`engine.BaseTask`.
        :param batch_size: number of instances in a batch.
        :param shuffle: whether to shuffle the instances while generating a
            batch.
        """
        self._task = task
        self._num_neg = num_neg
        self._column_names = inputs.dataframe.columns
        self.pairs = self.transform_data(inputs)
        super().__init__(batch_size, len(self.pairs), shuffle)

    def transform_data(self, inputs: datapack.DataPack) -> dict:
        """Obtain the transformed data from :class:`DataPack`.

        Note here, label is required to make pairs.

        :param inputs: An instance of :class:`DataPack` to be transformed.
        :return: the output of all the transformed inputs.
        """
        if 'label' not in self._column_names:
            raise ValueError(f"label is required from {inputs} \
                             to generate pairs.")
        aggregate_data = {}
        for _, row in inputs.dataframe.iterrows():
            # Note here the main id is set to be the id_left
            curr_kid = row['id_left']
            curr_label = row['label']
            if curr_kid not in aggregate_data:
                aggregate_data[curr_kid] = {}
            if curr_label not in aggregate_data[curr_kid]:
                aggregate_data[curr_kid][curr_label] = []
            aggregate_data[curr_kid][curr_label].append(row)
        all_pairs = []
        for kid, label_info in aggregate_data.items():
            label_list = sorted(label_info.keys(), reverse=True)
            for hidx, high_label in enumerate(label_list[:-1]):
                for high_sample in label_info[high_label]:
                    low_samples = []
                    for low_label in label_list[hidx+1:]:
                        for low_sample in label_info[low_label]:
                            low_samples.append(low_sample)
                    curr_pairs_num = len(low_samples) // self._num_neg
                    for idx in range(curr_pairs_num):
                        beg = idx * self._num_neg
                        end = (idx + 1) * self._num_neg
                        all_pairs.append((high_sample, low_samples[beg:end]))
        return np.asarray(all_pairs)

    def _get_batch_of_transformed_samples(
        self,
        index_array: list
    ) -> typing.Tuple[dict, typing.Any]:
        """Get a batch of samples based on their ids.

        :param index_array: a list of instance ids.
        :return: A batch of transformed samples.
        """
        batch_x = {}
        batch_y = []
        for pos_sample, neg_samples in self.pairs[index_array]:
            batch_y.append(pos_sample['label'])
            for neg_sample in neg_samples:
                batch_y.append(neg_sample['label'])
        for key in self._column_names:
            if key == 'label':
                continue
            batch_x[key] = []
            for pos_sample, neg_samples in self.pairs[index_array]:
                batch_x[key].append(pos_sample[key])
                for neg_sample in neg_samples:
                    batch_x[key].append(neg_sample[key])
            batch_x[key] = np.array(batch_x[key])
        batch_x = utils.dotdict(batch_x)
        return (batch_x, batch_y)

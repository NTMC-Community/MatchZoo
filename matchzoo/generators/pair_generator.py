"""Matchzoo pair generator."""

from matchzoo import engine
from matchzoo import datapack
from matchzoo import utils

import numpy as np
import typing


class PairGenerator(engine.BaseGenerator):
    """PairGenerator for Matchzoo.

    Pair generator can be used only for ranking.

    Examples:
        >>> data = [{
        ...     'text_left':[1], 'text_right': [2], 'id_left': 'id0',
        ...     'id_right': 'id1', 'label': 0},{
        ...     'text_left':[1], 'text_right': [3], 'id_left': 'id0',
        ...     'id_right': 'id2', 'label': 1}]
        >>> columns = ['text_left', 'text_right', 'id_left', 'id_right',
        ...     'label']
        >>> input = datapack.DataPack(data, columns=columns)
        >>> from matchzoo.generators import PairGenerator
        >>> generator = PairGenerator(input, 1, 1, True)
        >>> assert generator
        >>> x, y = generator[0]

    """

    def __init__(
        self,
        inputs: datapack.DataPack,
        num_neg: int=1,
        dup_ratio: int=4,
        batch_size: int=32,
        shuffle: bool=True
    ):
        """Construct the pair generator.

        :param inputs: the output generated by :class:`DataPack`.
        :param num_neg: the number of negative samples associated with each
            positive sample.
        :param dup_ratio: the number of duplicates for each positive sample.
        :param batch_size: number of instances in a batch.
        :param shuffle: whether to shuffle the instances while generating a
            batch.
        """
        self._num_neg = num_neg
        self._dup_ratio = dup_ratio
        self._column_names = inputs.dataframe.columns
        self.pairs = self.transform_data(inputs)
        super().__init__(batch_size, len(self.pairs), shuffle)

    def transform_data(self, inputs: datapack.DataPack) -> dict:
        """Obtain the transformed data from :class:`DataPack`.

        Note here, label is required to make pairs.

        :param inputs: An instance of :class:`DataPack` to be transformed.
        :return: the output of all the transformed inputs.
        """
        if 'label' not in self._column_names:
            raise ValueError(f"label is required from {inputs} \
                             to generate pairs.")
        # Note here the main id is set to be the id_left
        all_pairs = []
        for lists in inputs.dataframe.groupby('id_left'):
            sorted_ls = lists[1].sort_values('label', ascending=False)
            labels = sorted_ls.get('label').unique()
            for high_label in labels:
                high_samples = sorted_ls[sorted_ls.label == high_label]
                for _, pos_sample in high_samples.iterrows():
                    low_samples = sorted_ls[sorted_ls.label < high_label]
                    if len(low_samples) >= self._num_neg:
                        neg_sample = low_samples.sample(self._num_neg,
                                                        replace=True)
                        all_pairs.append((pos_sample, [neg_sample]))
        return np.asarray(all_pairs)

    def _get_batch_of_transformed_samples(
        self,
        index_array: list
    ) -> typing.Tuple[dict, typing.Any]:
        """Get a batch of samples based on their ids.

        :param index_array: a list of instance ids.
        :return: A batch of transformed samples.
        """
        batch_x = {}
        batch_y = []
        for pos_sample, neg_samples in self.pairs[index_array]:
            batch_y.append(pos_sample['label'])
            for _, neg_sample in neg_samples[0].iterrows():
                batch_y.append(neg_sample['label'])
        for key in self._column_names:
            if key == 'label':
                continue
            batch_x[key] = []
            for pos_sample, neg_samples in self.pairs[index_array]:
                batch_x[key].append(pos_sample[key])
                for _, neg_sample in neg_samples[0].iterrows():
                    batch_x[key].append(neg_sample[key])
            batch_x[key] = np.array(batch_x[key])
        batch_x = utils.dotdict(batch_x)
        return (batch_x, batch_y)
